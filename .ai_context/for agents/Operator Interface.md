# Описание Интерфейса: Оператор (`/operator`)

Рабочее место для создания и первичной обработки заявок. Является "фронт-офисом" системы.
Реализовано в компоненте: `components/OperatorInterface.tsx`.

---

## 1. Аутентификация
- **Компонент:** `OperatorAuthModal.tsx`
- **Логика:**
    - При загрузке страницы проверяется `localStorage.getItem('operatorToken')`.
    - Если токена нет, показывается модальное окно (z-index 300).
- **Действия:**
    - **Ввод токена вручную:** Пользователь вводит строку -> вызов `SupabaseService.loginWithToken(token)`.
        - *БД:* `SELECT * FROM app_users WHERE token = '...'`
    - **Кнопки "Демо 1" / "Демо 2":**
        - Клик -> Подставляет токены `op1` или `op2`.
        - Устанавливает пользователя в стейт `currentUser`.
        - Сохраняет токен в `localStorage`.

---

## 2. Левая панель: Создание Заявки
Компоненты: `OrderInfoForm`, `PartsList`, `AiAssistant`.

### 2.1. ИИ-Ассистент (`AiAssistant.tsx`)
- **Поле ввода:** `textarea` для вставки текста (email, мессенджер).
- **Событие:** `Ctrl + Enter` или клик по кнопке "РАСПОЗНАТЬ ЧЕРЕЗ AI".
- **Процесс:**
    1.  Отправка POST-запроса на `api.groq.com` (модель LLaMA 3).
    2.  Промпт требует вернуть JSON с полями `order_info` и `parts`.
    3.  **Обработка ответа:**
        - Метаданные (Телефон, Имя, Тема) -> обновляют стейт `orderInfo`.
        - Позиции -> нормализуются и добавляются в стейт `parts`.
        - **Поиск бренда:** Для каждой позиции AI пытается найти соответствие в `brandsList` (массив строк, загруженный при старте). Если точного совпадения нет, подставляется "сырое" значение.

### 2.2. Ручной ввод и редактирование
- **OrderInfoForm:**
    - Поля: Имя клиента, Телефон (обязательно), Email, Тема письма (email_subject), Регион, Город, Дедлайн.
    - *Важно:* Поле "Тема письма" используется в списке заказов для идентификации контекста.
- **PartsList:**
    - Таблица позиций.
    - **Автокомплит Бренда:**
        - `input` с выпадающим списком (фильтрация `brandsList`).
        - **Кнопка `+`:** Если бренда нет в списке, оператор нажимает `+`.
            - *БД:* `INSERT INTO brands (name) VALUES (...)`.
            - Локальный список `brandsList` обновляется мгновенно.
    - **Кнопки управления:** Удалить строку (Trash icon), Добавить строку (+).

### 2.3. Кнопка "СОЗДАТЬ ЗАЯВКУ"
- **Расположение:** Внизу компонента `AiAssistant` или формы.
- **Состояние `disabled` (Серая кнопка):**
    - Если массив `parts` пуст.
    - Если поле `clientPhone` пустое.
    - **Строгая валидация бренда:** Если хотя бы у одной позиции поле `brand` не совпадает ни с одним значением из `brandsList`. (Защита от "мусора" в базе).
- **Клик (Действие):**
    1.  Вызывается `handleCreateOrder`.
    2.  Формируется массив `items` для БД. В поле `comment` первой позиции записывается тема письма в формате `[Тема: ...]`.
    3.  **БД Запрос (`SupabaseService.createOrder`):**
        - `INSERT INTO orders` (поля: vin='VIN-UNKNOWN', status_admin='В обработке', owner_token=currentUser.token, ...).
        - Получаем `id` созданного заказа.
        - `INSERT INTO order_items` (массив позиций, привязанных к `order_id`).
    4.  **UI:**
        - Показ уведомления (Toast): "Заказ №... создан".
        - Очистка формы (`setParts`, `setOrderInfo`).
        - Триггер обновления списка заказов (`setRefreshTrigger`).

---

## 3. Правая панель: Список Заказов (Архив)
Компонент: `OperatorOrdersList.tsx`.

### 3.1. Загрузка данных
- **Хук:** `useEffect` с зависимостью `refreshTrigger`.
- **Запрос (`SupabaseService.getOrders`):**
    - `SELECT * FROM orders WHERE owner_token = '...'` (Изоляция данных).
    - Подгружает (join) `order_items` и `offers` (для отображения статусов и тем).
    - Пагинация (Infinite Scroll) через курсор.
- **Сортировка:** По умолчанию `id` (DESC) — новые сверху.

### 3.2. Табы (Фильтры статусов)
- **В обработке:** `status_admin = 'В обработке'`.
- **Обработанные:** `status_admin = 'КП готово'`.
- **Успешные:** `status_admin = 'Выполнен'`.
- **Забракованные:** `status_admin IN ('Аннулирован', 'Отказ')`.
- *Клик по табу:* Сбрасывает список и делает новый запрос с фильтром.

### 3.3. Строка Заказа (`OperatorOrderRow.tsx`)
Отображает краткую информацию.
- **Колонки:**
    1.  **ID:** Номер заказа (напр. #15).
    2.  **Клиент:** Имя + Телефон.
    3.  **Тема:** Извлекается из комментария первой позиции (`match(/\[Тема: (.*?)\]/)`).
    4.  **Дата:** `createdAt` (форматированная).
    5.  **Статус:** Цветной бейдж.
- **Клик по строке:** Переключает состояние `isExpanded`.
    - Если развернуто -> Загружает полные детали (`SupabaseService.getOrderDetails`), если их еще нет в кеше.

### 3.4. Детали Заказа (Развернутый вид)
- **Блок "Состав заявки":**
    - Рендерится список `items`.
    - Для каждой позиции: Название, Кол-во.
    - **Цена (adminPriceRub):**
        - Если менеджер выбрал поставщика и рассчитал цену, она приходит в поле `admin_price_rub` из таблицы `order_items`.
        - Отображается как `1 250 ₽` (синий бейдж).
- **Кнопка "Обработано":**
    - Видимость: Только если статус `В обработке`.
    - **Клик:** Вызывает `handleProcessed`.
        - *БД:* `UPDATE orders SET status_admin = 'КП готово', status_client = 'КП отправлено' ...`
        - UI: Обновляет список заказов (заказ перелетает в таб "Обработанные").
- **Кнопка Чата (в хедере или строке):**
    - Открывает модальное окно `GlobalChatWindow` с фильтром по данному `order_id`.

---

## 4. Глобальный Чат (`GlobalChatWindow.tsx`)
- **Роль:** Оператор выступает как `ADMIN` в структуре чата (общается с `SUPPLIER`).
- **Список слева:**
    - Группировка по `order_id`.
    - Показывает имя поставщика и последнее сообщение.
- **Окно диалога:**
    - `MessagesList`: Список сообщений.
    - `ChatInput`: Поле ввода + кнопка отправки.
    - **Отправка:**
        - *БД:* `INSERT INTO chat_messages (sender_role='ADMIN', sender_name='Оператор - [Имя]', ...)`
    - **Чтение:** При открытии чата отправляется запрос `markChatAsRead` для сообщений поставщика.

---

## 5. Технические особенности (Data Flow)
1.  **Изоляция:** Весь SQL-запрос списка заказов содержит `WHERE owner_token = current_user.token`. Это гарантирует, что оператор 1 не увидит заказы оператора 2.
2.  **Валидация брендов:** Список брендов загружается один раз при старте (`getBrandsList`) и обновляется при добавлении нового. Это предотвращает создание "мусорных" названий (напр. "Toyot", "Toyata").
3.  **Синхронизация цен:** Цены в интерфейсе оператора появляются *только* после того, как Менеджер нажмет "Выбрать" в своем интерфейсе. Это запускает триггер (в коде менеджера), который копирует цену из `offer_items` в `order_items`.