# Глубокое описание Взаимодействия и Логики (System Logic & Interaction)

Этот документ представляет собой исчерпывающее техническое описание бизнес-процессов, алгоритмов и потоков данных платформы. Предназначен для разработчиков и системных архитекторов.

---

## 1. Архитектура Жизненного Цикла Заказа (End-to-End Workflow)

Процесс обработки заявки представляет собой конечный автомат (State Machine), где переход между состояниями инициируется действиями пользователей или системными триггерами.

### ЭТАП 1: Инициализация (Ввод данных)
**Роль:** Оператор.
**Цель:** Превратить неструктурированный текст в валидную запись БД.

1.  **Захват данных (Ingestion):**
    *   **Канал A (Email):**
        *   *Сервис:* Node.js Worker (`sync_emails.cjs`) с поддержкой **IMAP IDLE**.
        *   *Логика:* Скрипт держит постоянное соединение. При событии `mail` загружает заголовки.
        *   *Фильтрация:* Применяется `SEARCH UNSEEN SINCE [Date]` + проверка темы (Regex: `/ЗАЯВКА/i`).
        *   *Результат:* Запись в таблицу `incoming_emails` (status='new').
    *   **Канал B (Manual/Chat):** Оператор копирует текст в интерфейс.

2.  **Обработка ИИ (Parsing):**
    *   *Инструмент:* Groq API (LLaMA 3).
    *   *Промпт:* Извлекает массив объектов `{name, brand, quantity, article}`.
    *   *Постобработка:* Приведение брендов к единому регистру.

3.  **Создание Заказа (Transaction):**
    *   **Действие:** Вызов `SupabaseService.createOrder`.
    *   **Валидация:** Проверка существования бренда в таблице `brands`. Если бренда нет — блокировка или запрос на создание (в зависимости от настроек UI).
    *   **SQL:**
        *   `INSERT INTO orders` (status_admin='В обработке', owner_token='op1').
        *   `INSERT INTO order_items` (массив позиций).
    *   **Изоляция:** Полю `owner_token` присваивается токен текущего оператора. Это включает RLS-политику, делающую заказ невидимым для других операторов.

### ЭТАП 2: Торги (Sourcing)
**Роль:** Закупщик (Поставщик).
**Цель:** Получить рыночные цены.

1.  **Дистрибуция (Broadcasting):**
    *   Заказ со статусом `В обработке` автоматически виден всем закупщикам в табе "Новые".
    *   **Исключение:** Работает SQL-фильтр `NOT IN (SELECT order_id FROM offers WHERE supplier_name = current_user)`. Если закупщик уже ответил, заказ исчезает из "Новых".

2.  **Подача Предложения (Bidding):**
    *   **Действие:** Закупщик заполняет форму и жмет "Отправить".
    *   **Метод:** `SupabaseService.createOffer`.
    *   **Атомарность:**
        1.  Проверка на дубликат оффера от этого поставщика.
        2.  `INSERT INTO offers` (связка с `order_id`).
        3.  `INSERT INTO offer_items` (копия позиций с ценами, сроками и весом).
        4.  `UPDATE orders SET status_supplier = 'Идут торги'`.
    *   **UX:** Заказ мгновенно перемещается в таб "Отправленные".

### ЭТАП 3: Квалификация и Расценка (Pricing)
**Роль:** Менеджер.
**Цель:** Сформировать коммерческое предложение (КП) для клиента.

1.  **Агрегация:** Менеджер видит сводную таблицу по каждому товару.
    *   *Группировка:* `Order Item` -> список `Offer Items` от разных поставщиков.

2.  **Авто-расчет Цены (Pricing Engine):**
    Система на лету (или при сохранении) считает `admin_price_rub` для каждой строки оффера.
    *   **Формула:**
        ```math
        BasePrice = (SellerPrice * CurrencyRate)
        Logistics = (Weight * DeliveryRateUSD * USD_RUB_Rate)
        TotalCost = BasePrice + Logistics
        FinalPrice = TotalCost * (1 + MarkupPercent / 100)
        ```
    *   *Источник курсов:* Таблица `exchange_rates` (берется последняя запись по дате).

3.  **Выбор Победителя (Selection):**
    *   **Действие:** Клик по кнопке "Выбрать" напротив оффера.
    *   **Метод:** `SupabaseService.updateRank`.
    *   **Логика (Optimistic UI):**
        1.  Интерфейс красит строку в зеленый мгновенно.
        2.  Отправляется запрос в БД: `UPDATE offer_items SET is_winner = true WHERE id = ...`.
        3.  **Синхронизация данных:** Рассчитанная цена (`admin_price_rub`) копируется из `offer_items` в родительскую таблицу `order_items`.
        *   *Зачем:* Оператор не имеет доступа к таблице `offers` (RLS). Чтобы он увидел цену, она должна лежать в `order_items`.
    *   **Множественность:** Разрешено выбирать несколько победителей на одну позицию (например, для разделения объема).

4.  **Утверждение КП (Approval):**
    *   **Действие:** Клик "Утвердить КП".
    *   **Валидация:** Система предупреждает, если есть позиции без выбранного лидера.
    *   **Результат:** `UPDATE orders SET status_admin = 'КП готово'`.

### ЭТАП 4: Продажа и CRM (Finalization)
**Роль:** Оператор + Автоматика.
**Цель:** Передать данные клиенту и зафиксировать сделку.

1.  **Синхронизация (Visibility):**
    *   Оператор видит заказ в табе "Обработанные" (фильтр `status IN ('КП готово', 'КП отправлено')`).
    *   В деталях заказа отображаются цены (`admin_price_rub`), которые утвердил менеджер.

2.  **Отправка Клиенту:**
    *   Оператор выгружает данные (копирует в буфер) и отправляет клиенту.
    *   Нажимает кнопку **"Отправлено клиенту"**.

3.  **CRM Триггер (Bitrix24 Integration):**
    Это критически важный автоматический процесс.
    *   **Event:** `UPDATE orders SET status_admin = 'КП отправлено'`.
    *   **Webhook:** Supabase вызывает Edge Function `create-bitrix-deal`.
    *   **Алгоритм Функции:**
        1.  **Bypass SSL:** Использует HTTP-соединение для обхода проблем с сертификатами на тестовых доменах.
        2.  **Поиск Клиента:** Делает запрос `crm.contact.list` по телефону из заказа.
            *   *Нашел:* Берет ID.
            *   *Не нашел:* Делает `crm.contact.add`.
        3.  **Создание Сделки:** `crm.deal.add` в стадии `UC_CWYRMB` ("Подписан").
        4.  **Товары:** `crm.deal.productrows.set` — передает список товаров с ценами `admin_price_rub`.
        5.  **Обратная связь:** ID созданной сделки записывается в поле `orders.bitrix_deal_id`.

4.  **Пост-процессинг:**
    *   Менеджер видит заказ в табе **"КП у клиента"**.
    *   Если клиент согласен, статус меняется на "Готов купить" (оператором или автоматически, если будет интеграция обратного вебхука).

---

## 2. Матрица Статусов и Видимости

Эта таблица определяет, где находится заказ в зависимости от его технического статуса.

| Технический статус (`status_admin`) | Роль: Оператор (Таб) | Роль: Менеджер (Таб) | Кто переводит? | Триггер события |
| :--- | :--- | :--- | :--- | :--- |
| `В обработке` | В обработке | Новые | Оператор | Создание заказа |
| `Идут торги` | В обработке | Новые | Система | Первый полученный оффер |
| `КП готово` | Обработанные | КП готово | Менеджер | Кнопка "Утвердить КП" |
| `КП отправлено` | Обработанные | КП у клиента | Оператор | Кнопка "Отправлено клиенту" |
| `Готов купить` | Обработанные | КП у клиента | Менеджер/Клиент | Подтверждение согласия |
| `Подтверждение от поставщика` | - | Подтверждено | Менеджер | Закупка запущена |
| `Ожидает оплаты` | - | Ждет оплаты | Менеджер | Счет выставлен |
| `В пути` | - | В пути | Менеджер | Груз отправлен |
| `Выполнен` | Успешные | Выполнен | Менеджер | Закрытие сделки |
| `Аннулирован` / `Отказ` | Забракованные | Аннулирован | Любой | Отмена / Неактуально |

---

## 3. Детальное описание Интеграций

### 3.1. Почтовый шлюз (Mail Gateway)
*   **Файл:** `sync_emails.cjs`
*   **Режим работы:** Hybrid (Push/Pull).
    *   **IMAP IDLE:** Основной режим. Скрипт "спит", пока сервер Gmail не пришлет сигнал `EXISTS`. Реакция < 1 сек.
    *   **Keep-Alive:** Пинги каждые 10 сек, перезапуск IDLE каждые 5 мин (защита от разрыва TCP).
*   **Санитизация:**
    *   `simpleParser` разбирает MIME-структуру.
    *   В базу пишется чистый текст (`text`) или HTML, если текста нет.
*   **Защита от дублей:**
    *   Используется флаг `\Seen` (прочитано) на сервере Gmail.
    *   Фильтр даты `SINCE` отсекает исторические письма при перезапуске скрипта.

### 3.2. CRM (Bitrix24)
*   **Файл:** `supabase/functions/create-bitrix-deal/index.ts`
*   **Тип:** Serverless Edge Function (Deno).
*   **Триггер:** Webhook базы данных (Database Webhook) -> `HTTP POST`.
*   **Payload:** Передается полная запись `record` (строка заказа).
*   **Идемпотентность:** Функция проверяет наличие `bitrix_deal_id`. Если поле уже заполнено, повторное создание сделки блокируется (защита от зацикливания вебхуков).
*   **Обработка ошибок:**
    *   В случае сбоя API Битрикса ошибка пишется в логи Supabase.
    *   Транзакция в Supabase не откатывается (status остается `КП отправлено`), но сделка не создается. Требуется ручной перезапуск или мониторинг логов.

---

## 4. Безопасность и Доступ (Security Model)

### 4.1. Row Level Security (RLS)
База данных защищена на уровне ядра PostgreSQL. Даже если злоумышленник получит доступ к API ключу `anon`, он не увидит данных.

*   **Policy: `Users can view their own orders`**
    *   `SELECT * FROM orders WHERE owner_token = current_setting('request.jwt.claim.sub')` (упрощенно).
    *   Реально используется проверка совпадения токена, переданного в заголовке или теле запроса, с полем `owner_token`.

### 4.2. Изоляция Офферов
*   **Закупщик:** Видит только свои офферы (`supplier_name = current_user`).
*   **Оператор:** Не видит офферы вообще, пока статус заказа не станет `КП готово`. Это реализовано на уровне UI (условный рендеринг) и может быть усилено RLS.
*   **Менеджер:** Видит всё (Superuser bypass).

### 4.3. Валидация Данных
*   **Бренды:** Строгая проверка по справочнику. Нельзя создать заказ с брендом "Тойота" (кириллица), если в базе "Toyota".
*   **Цены:** Все денежные поля хранятся как `numeric` или `integer`. UI форматирует их с разделителями тысяч.

---

## 5. Технический стек и Оптимизации

*   **Virtualization:** Списки заказов (Admin/Operator) используют `react-virtuoso`. Это позволяет рендерить 1000+ заказов без лагов, так как в DOM существует только ~10-20 видимых элементов.
*   **Optimistic Updates:** Все критические действия (смена статуса, выбор лидера) визуально применяются мгновенно. Если сервер вернет ошибку, интерфейс "откатится" назад (хотя в текущей реализации упор сделан на `refetch` для надежности).
*   **Database Indexes:**
    *   `idx_orders_status_admin` — для быстрой фильтрации табов.
    *   `idx_orders_owner_token` — для изоляции операторов.
    *   `idx_offer_items_order_item_id` — для быстрых джойнов при расчете КП.
