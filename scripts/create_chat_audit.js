import * as XLSX from 'xlsx';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const data = [
    {
        "Категория": "Архитектура",
        "Проблема": "Отсутствие сущности 'Тред' (Thread)",
        "Описание": "В БД нет таблицы чатов. Список формируется динамически (group by) на клиенте из последних 500 сообщений.",
        "Риск/Последствия": "Потеря старых чатов в UI. Если в активных чатах много сообщений, старые ветки вытесняются из выборки limit(500) и становятся невидимыми.",
        "Предлагаемое решение": "Создать Materialized View или таблицу 'chat_threads' (order_id, participant_ids, last_msg). Обновлять триггером.",
        "Приоритет": "CRITICAL"
    },
    {
        "Категория": "Данные",
        "Проблема": "Идентификация по Имени вместо UUID",
        "Описание": "В коде используются конструкции sender_name.eq, экранирование кавычек. Логика 'Name vs UUID' смешана.",
        "Риск/Последствия": "Коллизии имен. При смене имени пользователя история чата 'отваливается'. Сложность поддержки.",
        "Предлагаемое решение": "Полная миграция на UUID (sender_id). Имена подтягивать JOIN-ом только для отображения.",
        "Приоритет": "HIGH"
    },
    {
        "Категория": "Производительность",
        "Проблема": "Real-time Self-DDoS",
        "Описание": "При любом входящем сообщении (даже чужом) клиент перезапрашивает ВЕСЬ список тредов (fetchThreads).",
        "Риск/Последствия": "Лаги интерфейса при активной переписке. Лишняя нагрузка на БД (read heavy).",
        "Предлагаемое решение": "Оптимистичное обновление UI (добавлять сообщение в стейт локально). Подписка только на свои треды.",
        "Приоритет": "HIGH"
    },
    {
        "Категория": "Масштабируемость",
        "Проблема": "Отсутствие серверного поиска",
        "Описание": "Поиск по № заказа фильтрует только загруженные 500 сообщений в браузере.",
        "Риск/Последствия": "Невозможно найти старый заказ/чат через поиск, если он не попал в 'свежую' выборку.",
        "Предлагаемое решение": "Реализовать RPC-функцию search_chats(query) на стороне Supabase.",
        "Приоритет": "MEDIUM"
    },
    {
        "Категория": "Безопасность",
        "Проблема": "Фильтрация на клиенте (Client-side Security)",
        "Описание": "Менеджер видит всё, но фильтр 'не показывать чат Оператор-Закупщик' работает в JS/Service layer.",
        "Риск/Последствия": "Потенциальная утечка данных. Продвинутый пользователь может получить доступ к чужой переписке через API.",
        "Предлагаемое решение": "Перенести логику изоляции в RLS (Row Level Security) политики базы данных.",
        "Приоритет": "HIGH"
    },
    {
        "Категория": "Код/Поддержка",
        "Проблема": "Хардкод Ролей ('Магические строки')",
        "Описание": "Использование строковых литералов ['ADMIN', 'Менеджер'] в условиях if/else по всему коду.",
        "Риск/Последствия": "Хрупкость системы. Любое переименование роли сломает чат. Сложно отлаживать.",
        "Предлагаемое решение": "Вынести роли в константы (Enums). Унифицировать названия ролей в БД.",
        "Приоритет": "MEDIUM"
    },
    {
        "Категория": "UX",
        "Проблема": "Ненадежные счетчики непрочитанных",
        "Описание": "Счетчики пересчитываются на клиенте каждый раз. Зависят от полноты загрузки сообщений.",
        "Риск/Последствия": "Ложные уведомления или пропуск важных сообщений.",
        "Предлагаемое решение": "Хранить поле unread_count в таблице chat_threads или view.",
        "Приоритет": "LOW"
    }
];

const wb = XLSX.utils.book_new();
const ws = XLSX.utils.json_to_sheet(data);

// Adjust column widths
const wscols = [
    {wch: 20}, // Категория
    {wch: 35}, // Проблема
    {wch: 50}, // Описание
    {wch: 50}, // Риск
    {wch: 50}, // Решение
    {wch: 10}  // Приоритет
];
ws['!cols'] = wscols;

XLSX.utils.book_append_sheet(wb, ws, "Chat Audit");

const outputPath = path.resolve(__dirname, '../docs/Chat_System_Audit.xlsx');
XLSX.writeFile(wb, outputPath);

console.log(`Excel file created at: ${outputPath}`);
