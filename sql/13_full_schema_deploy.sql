-- FULL SCHEMA DEPLOYMENT SCRIPT
-- This script reconstructs the entire database structure.

-- ==========================================
-- 1. CLEANUP (Drop everything to start fresh)
-- ==========================================
DROP FUNCTION IF EXISTS public.get_seller_feed(TEXT, TEXT, INTEGER, INTEGER, TEXT, TEXT, TEXT, TEXT);
DROP FUNCTION IF EXISTS public.get_seller_brands(TEXT);
DROP FUNCTION IF EXISTS public.approve_order_winners(BIGINT, JSONB);
DROP FUNCTION IF EXISTS public.archive_old_chats();
DROP FUNCTION IF EXISTS public.reset_db();

DROP TABLE IF EXISTS public.chat_messages CASCADE;
DROP TABLE IF EXISTS public.offer_items CASCADE;
DROP TABLE IF EXISTS public.offers CASCADE;
DROP TABLE IF EXISTS public.order_items CASCADE;
DROP TABLE IF EXISTS public.orders CASCADE;

-- Enables Trigam extension for fast search
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- ==========================================
-- 2. BASE TABLES
-- ==========================================

-- Orders
CREATE TABLE public.orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    client_name TEXT NOT NULL,
    client_phone TEXT,
    car_brand TEXT,
    car_model TEXT,
    car_year TEXT,
    vin TEXT,
    status_admin TEXT DEFAULT 'В обработке',
    status_client TEXT DEFAULT 'В обработке',
    status_supplier TEXT DEFAULT 'Сбор предложений',
    location TEXT DEFAULT 'РФ',
    visible_to_client BOOLEAN DEFAULT FALSE,
    is_archived BOOLEAN DEFAULT FALSE,
    status_updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) -- From add_status_time.sql
);

-- Order Items
CREATE TABLE public.order_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id BIGINT REFERENCES public.orders(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    quantity INTEGER DEFAULT 1,
    comment TEXT,
    category TEXT DEFAULT 'Оригинал', -- From add_cols.sql
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Offers
CREATE TABLE public.offers (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id BIGINT REFERENCES public.orders(id) ON DELETE CASCADE,
    supplier_name TEXT NOT NULL,
    supplier_phone TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    status TEXT DEFAULT 'Активно'
);

-- Offer Items
CREATE TABLE public.offer_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    offer_id BIGINT REFERENCES public.offers(id) ON DELETE CASCADE,
    order_item_id BIGINT REFERENCES public.order_items(id), -- Optional link
    name TEXT NOT NULL,
    quantity INTEGER DEFAULT 1,
    price NUMERIC NOT NULL,
    currency TEXT DEFAULT 'RUB',
    delivery_days INTEGER,
    
    admin_price NUMERIC,
    admin_currency TEXT,
    is_winner BOOLEAN DEFAULT FALSE,
    
    -- From add_cols.sql & add_offer_comments.sql
    weight NUMERIC DEFAULT 0,
    photo_url TEXT,
    delivery_rate NUMERIC DEFAULT 0,
    comment TEXT,
    admin_comment TEXT,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Chat Messages (Combined from create_chat_table and migrations)
CREATE TABLE public.chat_messages (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id BIGINT REFERENCES public.orders(id) ON DELETE CASCADE NOT NULL,
    offer_id BIGINT REFERENCES public.offers(id) ON DELETE SET NULL,
    sender_role TEXT NOT NULL CHECK (sender_role IN ('ADMIN', 'SUPPLIER')),
    sender_name TEXT NOT NULL,
    recipient_name TEXT, -- From migration
    message TEXT NOT NULL,
    item_name TEXT, 
    is_read BOOLEAN DEFAULT FALSE,
    is_archived BOOLEAN DEFAULT FALSE, -- From migration
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- ==========================================
-- 3. INDEXES
-- ==========================================

-- Chat Indexes
CREATE INDEX idx_chat_order_supplier ON public.chat_messages(order_id, sender_name);
CREATE INDEX idx_chat_offer ON public.chat_messages(offer_id);
CREATE INDEX idx_chat_archived ON public.chat_messages(is_archived);
CREATE INDEX idx_chat_messages_order_id ON public.chat_messages(order_id);
CREATE INDEX idx_chat_messages_created_at ON public.chat_messages(created_at DESC);

-- Order Indexes (GIN & B-Tree)
CREATE INDEX idx_orders_vin_trgm ON public.orders USING gin (vin gin_trgm_ops);
CREATE INDEX idx_orders_client_name_trgm ON public.orders USING gin (client_name gin_trgm_ops);
CREATE INDEX idx_orders_client_phone_trgm ON public.orders USING gin (client_phone gin_trgm_ops);

-- Standard B-Tree Indexes (from add_indexes.sql)
CREATE INDEX idx_orders_status_admin ON public.orders(status_admin);
CREATE INDEX idx_orders_created_at ON public.orders(created_at DESC);
CREATE INDEX idx_orders_id ON public.orders(id);
CREATE INDEX idx_orders_car_brand ON public.orders(car_brand);
CREATE INDEX idx_orders_car_model ON public.orders(car_model);
CREATE INDEX idx_orders_vin ON public.orders(vin);
CREATE INDEX idx_orders_client_phone ON public.orders(client_phone);

-- Offer Indexes
CREATE INDEX idx_offers_order_id ON public.offers(order_id);
CREATE INDEX idx_offers_supplier_name ON public.offers(supplier_name);

-- Offer Items Indexes
CREATE INDEX idx_offer_items_offer_id ON public.offer_items(offer_id);
CREATE INDEX idx_offer_items_order_item_id ON public.offer_items(order_item_id);

-- ==========================================
-- 4. FUNCTIONS & COMPUTED COLUMNS
-- ==========================================

-- offers_count
CREATE OR REPLACE FUNCTION offers_count(orders_row orders)
RETURNS bigint AS $$
  SELECT COUNT(*) FROM offers WHERE order_id = orders_row.id;
$$ LANGUAGE sql STABLE;

-- total_cost
CREATE OR REPLACE FUNCTION public.total_cost(item public.offer_items)
RETURNS NUMERIC
LANGUAGE sql
STABLE
AS $$
  SELECT (
    COALESCE(item.admin_price, item.price, 0) * item.quantity 
    + 
    COALESCE(item.delivery_rate, 0)
  );
$$;

-- goods_cost
CREATE OR REPLACE FUNCTION public.goods_cost(item public.offer_items)
RETURNS NUMERIC
LANGUAGE sql
STABLE
AS $$
  SELECT (
    COALESCE(item.admin_price, item.price, 0) * item.quantity
  );
$$;

-- reset_db
CREATE OR REPLACE FUNCTION reset_db()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  TRUNCATE TABLE public.orders RESTART IDENTITY CASCADE;
END;
$$;

-- archive_old_chats
CREATE OR REPLACE FUNCTION public.archive_old_chats()
RETURNS void AS $$
BEGIN
    WITH stale_chats AS (
        SELECT order_id, sender_name, recipient_name
        FROM public.chat_messages
        GROUP BY order_id, sender_name, recipient_name
        HAVING MAX(created_at) < (now() - interval '3 days')
    )
    UPDATE public.chat_messages cm
    SET is_archived = TRUE
    FROM stale_chats sc
    WHERE cm.order_id = sc.order_id 
      AND (
          (cm.sender_name = sc.sender_name AND cm.recipient_name = sc.recipient_name)
          OR 
          (cm.sender_name = sc.recipient_name AND cm.recipient_name = sc.sender_name)
      )
      AND cm.is_archived = FALSE;
END;
$$ LANGUAGE plpgsql;

-- approve_order_winners
CREATE OR REPLACE FUNCTION public.approve_order_winners(
    p_order_id BIGINT,
    p_winners JSONB
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    w_item JSONB;
    w_id BIGINT;
    w_price NUMERIC;
    w_currency TEXT;
    w_delivery NUMERIC;
    w_comment TEXT;
    w_item_name TEXT;
BEGIN
    UPDATE public.orders
    SET 
        status_client = 'КП отправлено',
        status_admin = 'КП готово',
        status_updated_at = timezone('utc'::text, now())
    WHERE id = p_order_id;

    FOR w_item IN SELECT * FROM jsonb_array_elements(p_winners)
    LOOP
        w_id := (w_item->>'id')::BIGINT;
        w_price := (w_item->>'admin_price')::NUMERIC;
        w_currency := (w_item->>'admin_currency')::TEXT;
        w_delivery := (w_item->>'delivery_rate')::NUMERIC;
        w_comment := (w_item->>'admin_comment')::TEXT;

        SELECT name INTO w_item_name FROM public.offer_items WHERE id = w_id;

        UPDATE public.offer_items oi
        SET is_winner = FALSE
        FROM public.offers o
        WHERE oi.offer_id = o.id
          AND o.order_id = p_order_id
          AND oi.name = w_item_name;

        UPDATE public.offer_items
        SET 
            is_winner = TRUE,
            admin_price = w_price,
            admin_currency = w_currency,
            delivery_rate = w_delivery,
            admin_comment = w_comment
        WHERE id = w_id;
        
    END LOOP;
END;
$$;

-- get_seller_brands
CREATE OR REPLACE FUNCTION public.get_seller_brands(p_seller_name TEXT)
RETURNS TABLE (brand TEXT)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT DISTINCT car_brand
    FROM public.orders o
    WHERE 
       status_admin NOT IN ('ЗАКРЫТ', 'Аннулирован', 'Отказ', 'Выполнен', 'В пути')
       AND NOT EXISTS (
           SELECT 1 FROM public.offers off 
           WHERE off.order_id = o.id 
           AND TRIM(off.supplier_name) ILIKE TRIM(p_seller_name)
       )
    ORDER BY car_brand;
END;
$$;

-- get_seller_feed
CREATE OR REPLACE FUNCTION public.get_seller_feed(
    p_seller_name TEXT,
    p_tab TEXT,
    p_page INTEGER,
    p_limit INTEGER,
    p_search TEXT DEFAULT '',
    p_sort_col TEXT DEFAULT 'created_at',
    p_sort_dir TEXT DEFAULT 'desc',
    p_brand_filter TEXT DEFAULT NULL
)
RETURNS TABLE (
    id BIGINT,
    created_at TIMESTAMP WITH TIME ZONE,
    client_name TEXT,
    car_brand TEXT,
    car_model TEXT,
    car_year TEXT,
    vin TEXT,
    status_admin TEXT,
    status_client TEXT,
    status_supplier TEXT,
    visible_to_client BOOLEAN,
    offers_count BIGINT,
    items JSONB,
    my_offer JSONB,
    total_count BIGINT,
    count_new BIGINT,
    count_history BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_offset INTEGER := (p_page - 1) * p_limit;
    v_search_pattern TEXT := '%' || COALESCE(p_search, '') || '%';
BEGIN
    RETURN QUERY
    WITH base_orders AS (
        SELECT 
            o.*,
            (SELECT COUNT(*) FROM public.offers off WHERE off.order_id = o.id) as o_count,
            (
                SELECT row_to_json(off_data)::jsonb
                FROM (
                    SELECT 
                        off.id, 
                        off.supplier_name, 
                        (
                            SELECT jsonb_agg(jsonb_build_object('id', ofi.id, 'name', ofi.name, 'quantity', ofi.quantity, 'sellerPrice', ofi.price, 'weight', ofi.weight, 'deliveryWeeks', ofi.delivery_days / 7, 'photoUrl', ofi.photo_url, 'offeredQuantity', ofi.quantity, 'rank', CASE WHEN ofi.is_winner THEN 'ЛИДЕР' ELSE '' END, 'adminComment', ofi.admin_comment))
                            FROM public.offer_items ofi
                            WHERE ofi.offer_id = off.id
                        ) as items
                    FROM public.offers off
                    WHERE off.order_id = o.id AND TRIM(off.supplier_name) ILIKE TRIM(p_seller_name)
                    LIMIT 1
                ) off_data
            ) as my_off
        FROM public.orders o
        WHERE 
            (COALESCE(p_search, '') = '' OR (
                o.vin ILIKE v_search_pattern OR
                o.id::TEXT ILIKE v_search_pattern OR
                o.car_model ILIKE v_search_pattern OR
                o.car_brand ILIKE v_search_pattern
            ))
            AND (p_brand_filter IS NULL OR o.car_brand ILIKE p_brand_filter)
    ),
    tab_new AS (
        SELECT * FROM base_orders 
        WHERE my_off IS NULL 
          AND status_admin NOT IN ('ЗАКРЫТ', 'Аннулирован', 'Отказ', 'Выполнен', 'В пути')
    ),
    tab_history AS (
        SELECT * FROM base_orders WHERE my_off IS NOT NULL
    ),
    counts AS (
        SELECT 
            (SELECT COUNT(*) FROM tab_new) as c_new,
            (SELECT COUNT(*) FROM tab_history) as c_history
    )
    SELECT 
        ct.id, ct.created_at, ct.client_name, ct.car_brand, ct.car_model, ct.car_year, ct.vin, 
        ct.status_admin, ct.status_client, ct.status_supplier, ct.visible_to_client, ct.o_count,
        (SELECT jsonb_agg(jsonb_build_object('id', oi.id, 'name', oi.name, 'quantity', oi.quantity, 'category', oi.category)) FROM public.order_items oi WHERE oi.order_id = ct.id) as items,
        ct.my_off,
        (SELECT COUNT(*) FROM (SELECT 1 FROM tab_new WHERE p_tab = 'new' UNION ALL SELECT 1 FROM tab_history WHERE p_tab = 'history') t) as c_total,
        c.c_new,
        c.c_history
    FROM (
        SELECT * FROM tab_new WHERE p_tab = 'new'
        UNION ALL
        SELECT * FROM tab_history WHERE p_tab = 'history'
    ) ct, counts c
    ORDER BY 
        CASE WHEN p_sort_dir = 'asc' THEN
            CASE 
                WHEN p_sort_col = 'id' THEN ct.id::TEXT
                WHEN p_sort_col = 'brand' THEN ct.car_brand
                WHEN p_sort_col = 'model' THEN ct.car_model
                ELSE ct.created_at::TEXT
            END
        END ASC,
        CASE WHEN p_sort_dir = 'desc' THEN
            CASE 
                WHEN p_sort_col = 'id' THEN ct.id::TEXT
                WHEN p_sort_col = 'brand' THEN ct.car_brand
                WHEN p_sort_col = 'model' THEN ct.car_model
                ELSE ct.created_at::TEXT
            END
        END DESC
    LIMIT p_limit
    OFFSET v_offset;
END;
$$;

-- ==========================================
-- 5. RLS Policies
-- ==========================================
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.order_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.offers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.offer_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_messages ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Enable all access for now" ON public.orders FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Enable all access for now" ON public.order_items FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Enable all access for now" ON public.offers FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Enable all access for now" ON public.offer_items FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Enable all access for now" ON public.chat_messages FOR ALL USING (true) WITH CHECK (true);

-- Refresh schema
NOTIFY pgrst, 'reload schema';
