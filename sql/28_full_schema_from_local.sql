-- FULL SCHEMA FROM LOCAL (Generated from inspection)
-- Use this to clone your local database structure to the cloud.

-- ==========================================
-- 1. CLEANUP
-- ==========================================

-- Drop functions with specific signatures (to handle overloads cleanly)
DROP FUNCTION IF EXISTS public.get_seller_feed(TEXT, TEXT, INTEGER, INTEGER, TEXT, TEXT, TEXT, TEXT); -- New 8-arg version
DROP FUNCTION IF EXISTS public.get_seller_feed(TEXT, TEXT, INTEGER, INTEGER, TEXT); -- Old 5-arg version
DROP FUNCTION IF EXISTS public.get_seller_brands(TEXT);
DROP FUNCTION IF EXISTS public.approve_order_winners(BIGINT, JSONB);
DROP FUNCTION IF EXISTS public.archive_old_chats();
DROP FUNCTION IF EXISTS public.debug_seller_feed(TEXT);
DROP FUNCTION IF EXISTS public.offers_count(public.orders);
DROP FUNCTION IF EXISTS public.goods_cost(public.offer_items);
DROP FUNCTION IF EXISTS public.total_cost(public.offer_items); -- Including this as it is used in code
DROP FUNCTION IF EXISTS public.reset_db();

-- Drop tables with CASCADE
DROP TABLE IF EXISTS public.chat_messages CASCADE;
DROP TABLE IF EXISTS public.offer_items CASCADE;
DROP TABLE IF EXISTS public.offers CASCADE;
DROP TABLE IF EXISTS public.order_items CASCADE;
DROP TABLE IF EXISTS public.orders CASCADE;

-- ==========================================
-- 2. TABLES
-- ==========================================

-- Orders
CREATE TABLE public.orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    client_name TEXT NOT NULL,
    client_phone TEXT,
    car_brand TEXT,
    car_model TEXT,
    car_year TEXT,
    vin TEXT,
    status_admin TEXT DEFAULT 'В обработке',
    status_client TEXT DEFAULT 'В обработке',
    status_supplier TEXT DEFAULT 'Сбор предложений',
    location TEXT DEFAULT 'РФ',
    visible_to_client BOOLEAN DEFAULT FALSE,
    is_archived BOOLEAN DEFAULT FALSE,
    status_updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() -- Matches local DB exactly
);

-- Order Items
CREATE TABLE public.order_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id BIGINT REFERENCES public.orders(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    quantity INTEGER DEFAULT 1,
    comment TEXT,
    category TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Offers
CREATE TABLE public.offers (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id BIGINT REFERENCES public.orders(id) ON DELETE CASCADE,
    supplier_name TEXT NOT NULL,
    supplier_phone TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    status TEXT DEFAULT 'Активно'
);

-- Offer Items
CREATE TABLE public.offer_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    offer_id BIGINT REFERENCES public.offers(id) ON DELETE CASCADE,
    order_item_id BIGINT REFERENCES public.order_items(id),
    name TEXT NOT NULL,
    quantity INTEGER DEFAULT 1,
    price NUMERIC NOT NULL,
    currency TEXT DEFAULT 'RUB',
    delivery_days INTEGER,
    
    admin_price NUMERIC,
    admin_currency TEXT,
    is_winner BOOLEAN DEFAULT FALSE,
    
    weight NUMERIC DEFAULT 0,
    photo_url TEXT,
    admin_comment TEXT,
    delivery_rate NUMERIC DEFAULT 0,
    comment TEXT,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Chat Messages
CREATE TABLE public.chat_messages (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id BIGINT REFERENCES public.orders(id) ON DELETE CASCADE NOT NULL,
    offer_id BIGINT REFERENCES public.offers(id) ON DELETE SET NULL,
    sender_role TEXT NOT NULL CHECK (sender_role IN ('ADMIN', 'SUPPLIER')),
    sender_name TEXT NOT NULL,
    message TEXT NOT NULL,
    item_name TEXT,
    is_read BOOLEAN DEFAULT FALSE,
    recipient_name TEXT,
    is_archived BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- ==========================================
-- 3. INDEXES (From standard set)
-- ==========================================
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Orders
CREATE INDEX idx_orders_vin_trgm ON public.orders USING gin (vin gin_trgm_ops);
CREATE INDEX idx_orders_client_name_trgm ON public.orders USING gin (client_name gin_trgm_ops);
CREATE INDEX idx_orders_client_phone_trgm ON public.orders USING gin (client_phone gin_trgm_ops);
CREATE INDEX idx_orders_status_admin ON public.orders(status_admin);
CREATE INDEX idx_orders_created_at ON public.orders(created_at DESC);
CREATE INDEX idx_orders_id ON public.orders(id);
CREATE INDEX idx_orders_car_brand ON public.orders(car_brand);
CREATE INDEX idx_orders_car_model ON public.orders(car_model);
CREATE INDEX idx_orders_vin ON public.orders(vin);
CREATE INDEX idx_orders_client_phone ON public.orders(client_phone);

-- Offers
CREATE INDEX idx_offers_order_id ON public.offers(order_id);
CREATE INDEX idx_offers_supplier_name ON public.offers(supplier_name);

-- Offer Items
CREATE INDEX idx_offer_items_offer_id ON public.offer_items(offer_id);
CREATE INDEX idx_offer_items_order_item_id ON public.offer_items(order_item_id);

-- Chat
CREATE INDEX idx_chat_order_supplier ON public.chat_messages(order_id, sender_name);
CREATE INDEX idx_chat_offer ON public.chat_messages(offer_id);
CREATE INDEX idx_chat_archived ON public.chat_messages(is_archived);
CREATE INDEX idx_chat_messages_order_id ON public.chat_messages(order_id);
CREATE INDEX idx_chat_messages_created_at ON public.chat_messages(created_at DESC);

-- ==========================================
-- 4. FUNCTIONS (From Local Definitions)
-- ==========================================

-- offers_count
CREATE OR REPLACE FUNCTION public.offers_count(orders_row public.orders)
RETURNS bigint
LANGUAGE sql
STABLE
AS $function$
  SELECT COUNT(*) FROM offers WHERE order_id = orders_row.id;
$function$;

-- goods_cost
CREATE OR REPLACE FUNCTION public.goods_cost(item public.offer_items)
RETURNS numeric
LANGUAGE sql
STABLE
AS $function$
  SELECT (
    COALESCE(item.admin_price, item.price, 0) * item.quantity
  );
$function$;

-- total_cost (Restored as it is required by app)
CREATE OR REPLACE FUNCTION public.total_cost(item public.offer_items)
RETURNS numeric
LANGUAGE sql
STABLE
AS $function$
  SELECT (
    COALESCE(item.admin_price, item.price, 0) * item.quantity 
    + 
    COALESCE(item.delivery_rate, 0)
  );
$function$;

-- approve_order_winners
CREATE OR REPLACE FUNCTION public.approve_order_winners(p_order_id bigint, p_winners jsonb)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    w_item JSONB;
    w_id BIGINT;
    w_price NUMERIC;
    w_currency TEXT;
    w_delivery NUMERIC;
    w_comment TEXT;
    w_item_name TEXT;
BEGIN
    -- А. Обновляем статус заказа и ВРЕМЯ ОБНОВЛЕНИЯ
    UPDATE public.orders
    SET 
        status_client = 'КП отправлено',
        status_admin = 'КП готово',
        status_updated_at = timezone('utc'::text, now()) -- <--- ВАЖНО: Обновляем время
    WHERE id = p_order_id;

    -- Б. Обрабатываем победителей
    FOR w_item IN SELECT * FROM jsonb_array_elements(p_winners)
    LOOP
        w_id := (w_item->>'id')::BIGINT;
        w_price := (w_item->>'admin_price')::NUMERIC;
        w_currency := (w_item->>'admin_currency')::TEXT;
        w_delivery := (w_item->>'delivery_rate')::NUMERIC;
        w_comment := (w_item->>'admin_comment')::TEXT;

        SELECT name INTO w_item_name FROM public.offer_items WHERE id = w_id;

        UPDATE public.offer_items oi
        SET is_winner = FALSE
        FROM public.offers o
        WHERE oi.offer_id = o.id
          AND o.order_id = p_order_id
          AND oi.name = w_item_name;

        UPDATE public.offer_items
        SET 
            is_winner = TRUE,
            admin_price = w_price,
            admin_currency = w_currency,
            delivery_rate = w_delivery,
            admin_comment = w_comment
        WHERE id = w_id;
        
    END LOOP;
END;
$function$;

-- get_seller_brands
CREATE OR REPLACE FUNCTION public.get_seller_brands(p_seller_name text)
RETURNS TABLE(brand text)
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT DISTINCT car_brand
    FROM public.orders o
    WHERE 
       -- Условия как для таба 'new' (то, что можно взять в работу)
       status_admin NOT IN ('ЗАКРЫТ', 'Аннулирован', 'Отказ', 'Выполнен', 'В пути')
       AND NOT EXISTS (
           SELECT 1 FROM public.offers off 
           WHERE off.order_id = o.id 
           AND TRIM(off.supplier_name) ILIKE TRIM(p_seller_name)
       )
    ORDER BY car_brand;
END;
$function$;

-- archive_old_chats
CREATE OR REPLACE FUNCTION public.archive_old_chats()
RETURNS void
LANGUAGE plpgsql
AS $function$
BEGIN
    -- Находим группы (order_id, supplier_name), где последнее сообщение старше 3 дней
    WITH stale_chats AS (
        SELECT order_id, sender_name, recipient_name
        FROM public.chat_messages
        GROUP BY order_id, sender_name, recipient_name
        HAVING MAX(created_at) < (now() - interval '3 days')
    )
    UPDATE public.chat_messages cm
    SET is_archived = TRUE
    FROM stale_chats sc
    WHERE cm.order_id = sc.order_id 
      AND (
          (cm.sender_name = sc.sender_name AND cm.recipient_name = sc.recipient_name)
          OR 
          (cm.sender_name = sc.recipient_name AND cm.recipient_name = sc.sender_name)
      )
      AND cm.is_archived = FALSE;
END;
$function$;

-- debug_seller_feed
CREATE OR REPLACE FUNCTION public.debug_seller_feed(p_seller_name text)
RETURNS TABLE(info text, val text)
LANGUAGE plpgsql
AS $function$
DECLARE
    v_total_orders BIGINT;
    v_open_orders BIGINT;
    v_my_offers_count BIGINT;
    v_sample_status TEXT;
    v_sample_offer_name TEXT;
BEGIN
    -- 1. Всего заказов
    SELECT COUNT(*) INTO v_total_orders FROM public.orders;
    RETURN QUERY SELECT 'Total Orders'::TEXT, v_total_orders::TEXT;

    -- 2. Открытых заказов (проверка статусов)
    SELECT COUNT(*) INTO v_open_orders FROM public.orders 
    WHERE status_admin NOT IN ('ЗАКРЫТ', 'Аннулирован', 'Отказ', 'Выполнен', 'В пути');
    RETURN QUERY SELECT 'Open Orders (Filtered)'::TEXT, v_open_orders::TEXT;

    -- 3. Пример статуса одного заказа
    SELECT status_admin INTO v_sample_status FROM public.orders LIMIT 1;
    RETURN QUERY SELECT 'Sample Status'::TEXT, v_sample_status::TEXT;

    -- 4. Сколько офферов с таким именем (проверка ILIKE)
    SELECT COUNT(*) INTO v_my_offers_count FROM public.offers 
    WHERE TRIM(supplier_name) ILIKE TRIM(p_seller_name);
    RETURN QUERY SELECT 'Offers Found for Seller'::TEXT, v_my_offers_count::TEXT;

    -- 5. Пример имени поставщика из базы (первый попавшийся)
    SELECT supplier_name INTO v_sample_offer_name FROM public.offers LIMIT 1;
    RETURN QUERY SELECT 'Sample Offer Name in DB'::TEXT, v_sample_offer_name::TEXT;
    
    -- 6. Что мы искали
    RETURN QUERY SELECT 'Searching For'::TEXT, p_seller_name;
END;
$function$;

-- get_seller_feed (OPTIMIZED 8-ARG VERSION)
CREATE OR REPLACE FUNCTION public.get_seller_feed(
    p_seller_name text,
    p_tab text,
    p_page integer,
    p_limit integer,
    p_search text DEFAULT ''::text,
    p_sort_col text DEFAULT 'created_at'::text,
    p_sort_dir text DEFAULT 'desc'::text,
    p_brand_filter text DEFAULT NULL::text
)
RETURNS TABLE(
    id bigint,
    created_at timestamp with time zone,
    client_name text,
    car_brand text,
    car_model text,
    car_year text,
    vin text,
    status_admin text,
    status_client text,
    status_supplier text,
    visible_to_client boolean,
    offers_count bigint,
    items jsonb,
    my_offer jsonb,
    total_count bigint,
    count_new bigint,
    count_history bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
    v_offset INTEGER := (p_page - 1) * p_limit;
    v_search_safe TEXT := COALESCE(p_search, '');
    v_search_pattern TEXT := '%' || v_search_safe || '%';
    v_sql TEXT;
    v_sort_clause TEXT;
BEGIN
    IF p_sort_col = 'id' THEN v_sort_clause := 'ct.id';
    ELSIF p_sort_col = 'brand' THEN v_sort_clause := 'ct.car_brand';
    ELSIF p_sort_col = 'model' THEN v_sort_clause := 'ct.car_model';
    ELSE v_sort_clause := 'ct.created_at'; END IF;

    IF p_sort_dir = 'asc' THEN v_sort_clause := v_sort_clause || ' ASC';
    ELSE v_sort_clause := v_sort_clause || ' DESC'; END IF;

    v_sql := '
    WITH base_orders AS (
        SELECT 
            o.*,
            (SELECT COUNT(*) FROM public.offers off WHERE off.order_id = o.id) as o_count,
            (
                SELECT row_to_json(off_data)::jsonb
                FROM (
                    SELECT 
                        off.id, 
                        off.supplier_name, 
                        (
                            SELECT jsonb_agg(
                                jsonb_build_object(''id'', ofi.id, ''name'', ofi.name, ''quantity'', ofi.quantity, ''sellerPrice'', ofi.price, ''weight'', ofi.weight, ''deliveryWeeks'', ofi.delivery_days / 7, ''photoUrl'', ofi.photo_url, ''offeredQuantity'', ofi.quantity, ''rank'', CASE WHEN ofi.is_winner THEN ''ЛИДЕР'' ELSE '''' END, ''adminComment'', ofi.admin_comment)
                            )
                            FROM public.offer_items ofi
                            WHERE ofi.offer_id = off.id
                        ) as items
                    FROM public.offers off
                    WHERE off.order_id = o.id AND TRIM(off.supplier_name) ILIKE TRIM($1)
                    LIMIT 1
                ) off_data
            ) as my_off
        FROM public.orders o
        WHERE 
            -- Поиск (ID, VIN, Model, Items)
            ($2 = '''' OR (
                o.vin ILIKE $3 OR
                o.id::TEXT ILIKE $3 OR
                o.car_model ILIKE $3 OR
                o.car_brand ILIKE $3 OR
                EXISTS (
                    SELECT 1 FROM public.order_items oi 
                    WHERE oi.order_id = o.id AND oi.name ILIKE $3
                )
            ))
            -- Фильтр по бренду
            AND ($7 IS NULL OR o.car_brand ILIKE $7)
    ),
    tab_new AS (
        SELECT * FROM base_orders 
        WHERE my_off IS NULL 
          AND status_admin NOT IN (''ЗАКРЫТ'', ''Аннулирован'', ''Отказ'', ''Выполнен'', ''В пути'')
    ),
    tab_history AS (
        SELECT * FROM base_orders WHERE my_off IS NOT NULL
    ),
    current_tab AS (
        SELECT * FROM 
        CASE 
            WHEN $4 = ''new'' THEN (SELECT * FROM tab_new)
            WHEN $4 = ''history'' THEN (SELECT * FROM tab_history)
            ELSE NULL
        END t
    ),
    counts AS (
        SELECT 
            (SELECT COUNT(*) FROM tab_new) as c_new,
            (SELECT COUNT(*) FROM tab_history) as c_history
    )
    SELECT 
        ct.id, ct.created_at, ct.client_name, ct.car_brand, ct.car_model, ct.car_year, ct.vin, 
        ct.status_admin, ct.status_client, ct.status_supplier, ct.visible_to_client, ct.o_count,
        (SELECT jsonb_agg(jsonb_build_object(''id'', oi.id, ''name'', oi.name, ''quantity'', oi.quantity, ''category'', oi.category)) FROM public.order_items oi WHERE oi.order_id = ct.id) as items,
        ct.my_off,
        (SELECT COUNT(*) FROM current_tab) as c_total,
        c.c_new, c.c_history
    FROM current_tab ct, counts c
    ORDER BY ' || v_sort_clause || '
    LIMIT $5 OFFSET $6';

    RETURN QUERY EXECUTE v_sql 
    USING p_seller_name, v_search_safe, v_search_pattern, p_tab, p_limit, v_offset, p_brand_filter;
END;
$function$;

-- reset_db
CREATE OR REPLACE FUNCTION public.reset_db()
RETURNS void
LANGUAGE plpgsql
AS $function$
BEGIN
  -- TRUNCATE удаляет всё из таблицы мгновенно
  -- RESTART IDENTITY сбрасывает счетчик ID на 1
  -- CASCADE удаляет зависимые данные (товары, офферы)
  TRUNCATE TABLE public.orders RESTART IDENTITY CASCADE;
END;
$function$;

-- ==========================================
-- 5. RLS POLICIES
-- ==========================================
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.order_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.offers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.offer_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_messages ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Enable all access for now" ON public.orders FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Enable all access for now" ON public.order_items FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Enable all access for now" ON public.offers FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Enable all access for now" ON public.offer_items FOR ALL USING (true) WITH CHECK (true);
CREATE POLICY "Enable all access for now" ON public.chat_messages FOR ALL USING (true) WITH CHECK (true);

-- Refresh schema
NOTIFY pgrst, 'reload schema';
